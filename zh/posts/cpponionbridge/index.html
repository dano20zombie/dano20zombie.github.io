<!DOCTYPE html>
<html lang="zh">
<head>
  
    <title>CppOnionBridge：匿名上网的创新 :: dano20zombie的博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="探索CppOnionBridge，这是匿名浏览互联网的终极解决方案。本文深入探讨了该项目如何通过Tor网络提供对洋葱站点和API的安全和受保护访问，强调了在数字时代隐私和在线安全的重要性。适合希望增强在线体验同时保护数字身份的Windows用户。" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://dano20zombie.github.io/zh/posts/cpponionbridge/" />






  
  
  
  
  
  <link rel="stylesheet" href="https://dano20zombie.github.io/styles.css">







  <link rel="shortcut icon" href="https://dano20zombie.github.io/favicon.ico">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="zh" />
<meta property="og:type" content="article" />
<meta property="og:title" content="CppOnionBridge：匿名上网的创新">
<meta property="og:description" content="探索CppOnionBridge，这是匿名浏览互联网的终极解决方案。本文深入探讨了该项目如何通过Tor网络提供对洋葱站点和API的安全和受保护访问，强调了在数字时代隐私和在线安全的重要性。适合希望增强在线体验同时保护数字身份的Windows用户。" />
<meta property="og:url" content="https://dano20zombie.github.io/zh/posts/cpponionbridge/" />
<meta property="og:site_name" content="dano20zombie的博客" />

  
    <meta property="og:image" content="https://dano20zombie.github.io/favicon.ico">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="安全" />

  <meta property="article:section" content="技术" />


  <meta property="article:published_time" content="2024-02-17 00:00:00 &#43;0000 UTC" />












</head>
<body class="red">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/zh">
  <div class="logo">
    dano20zombie的博客
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/zh/about">关于我</a></li>
        
      
        
          <li><a href="/zh/showcase">展示</a></li>
        
      
      
        <hr />
        
          <li>
            <a href="https://dano20zombie.github.io/en/">English</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/zh/">中文</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/es/">Español</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/fr/">Français</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/it/">Italiano</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/ar/">العربية</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/de/">Deutsch</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/ru/">Русский</a>
          </li>
        
      
    </ul>
  </li>
</ul>

    
    
      <ul class="menu menu--desktop menu--language-selector">
  <li class="menu__trigger">中文&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        <li><a href="https://dano20zombie.github.io/en/">English</a></li>
      
        <li><a href="https://dano20zombie.github.io/zh/">中文</a></li>
      
        <li><a href="https://dano20zombie.github.io/es/">Español</a></li>
      
        <li><a href="https://dano20zombie.github.io/fr/">Français</a></li>
      
        <li><a href="https://dano20zombie.github.io/it/">Italiano</a></li>
      
        <li><a href="https://dano20zombie.github.io/ar/">العربية</a></li>
      
        <li><a href="https://dano20zombie.github.io/de/">Deutsch</a></li>
      
        <li><a href="https://dano20zombie.github.io/ru/">Русский</a></li>
      
    </ul>
  </li>
</ul>

    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/zh/about" >关于我</a></li>
        
      
        
          <li><a href="/zh/showcase" >展示</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://dano20zombie.github.io/zh/posts/cpponionbridge/">CppOnionBridge：匿名上网的创新</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-02-17</time><span class="post-reading-time">3 min read (439 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://dano20zombie.github.io/zh/tags/cpponionbridge/">CppOnionBridge</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/zh/tags/tor%E7%BD%91%E7%BB%9C/">Tor网络</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/zh/tags/%E5%9C%A8%E7%BA%BF%E5%8C%BF%E5%90%8D/">在线匿名</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/zh/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/zh/tags/c&#43;&#43;/">C&#43;&#43;</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="免责声明">免责声明<a href="#免责声明" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>本文和CppOnionBridge项目旨在促进在线隐私和安全。使用工具进行匿名浏览互联网应始终遵守当地法律法规。我们提醒您，对于此类工具的使用责任由最终用户承担。本内容按原样提供，不对其准确性或及时性提供任何形式的保证。</p>
<h2 id="简介">简介<a href="#简介" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>在当前环境中，网络隐私不断受到威胁，<strong>CppOnionBridge</strong>呈现为一种前卫的解决方案，确保用户可以匿名且安全地访问互联网。这个项目专注于Windows环境的开发，允许通过Tor网络安全地访问洋葱站点和API，利用了SOCKS5协议。</p>
<h2 id="愿景">愿景<a href="#愿景" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><strong>CppOnionBridge</strong>背后的愿景很明确：提供一种工具，不仅保护用户的在线身份，还使Tor网络的强大功能对开发人员和最终用户可轻松访问，减少技术上的努力。该项目通过Tor封装SSL/TLS连接和HTTP(S)请求的复杂性，使得可以专注于应用功能。</p>
<h2 id="特点与优势">特点与优势<a href="#特点与优势" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li><strong>易集成性</strong>：设计为可以轻松集成到C++应用程序中，<strong>CppOnionBridge</strong>降低了开发安全应用程序的准入门槛。</li>
<li><strong>最小依赖性</strong>：仅依赖于Boost进行网络和系统操作以及OpenSSL进行加密连接，使其保持轻量级且与开发环境无关。</li>
<li><strong>SOCKS5兼容性</strong>：确保与Tor网络的流畅且安全的交互，为需要匿名和安全性的各种应用程序打开了大门。</li>
</ul>
<h2 id="什么是socks5">什么是SOCKS5<a href="#什么是socks5" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>SOCKS是一种互联网协议，通过代理服务器在客户端和服务器之间交换网络数据包。SOCKS5可选择性提供身份验证，以便只有授权用户可以访问服务器。</p>
<h2 id="为什么选择socks5">为什么选择SOCKS5<a href="#为什么选择socks5" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>选择SOCKS5协议是因为其灵活性和安全性。其客户端-服务器架构允许通过Tor封装HTTP(S)请求和SSL/TLS连接，确保与网络的安全和匿名交互。此外，其与各种应用程序的兼容性使其成为确保匿名和在线安全的理想选择。(<a href="https://en.wikipedia.org/wiki/SOCKS">维基百科</a>)
SOCKS5服务器充当您和最终主机之间的代理，将您计算机上的数据包发送到连接的另一侧，反之亦然。
TOR已经为我们提供了基于默认本地端口9050的SOCKS5接口，但在本示例中，我们将使用端口9150。</p>
<h2 id="工作原理">工作原理<a href="#工作原理" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>CppOnionBridge依赖于两个外部库：Boost和OpenSSL，因此让我们从项目中包含它们开始：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/http.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/ssl.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/version.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/connect.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/ip/tcp.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/ssl/error.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/ssl/stream.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment(lib, &#34;libcrypto64MD.lib&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment(lib, &#34;libssl64MD.lib&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Definizioni di namespace per semplificare il codice
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> beast <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>beast;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> http <span style="color:#f92672">=</span> beast<span style="color:#f92672">::</span>http;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> ssl <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> asio <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>asio;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> error <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>error;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> tcp <span style="color:#f92672">=</span> asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> host <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bible4u2lvhacg4b3to2e2veqpwmrc2c3tjf2wuuqiz332vlwmr4xbad.onion&#34;</span>; <span style="color:#75715e">// Bible4u
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> api <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/en/about&#34;</span>; <span style="color:#75715e">// About Page
</span></span></span></code></pre></div><p>完成了上述步骤后，作为我们的第一个实际步骤，我们需要创建一个套接字并连接到本地主机地址，使用我们指定的端口（127.0.0.1:9150）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>asio<span style="color:#f92672">::</span>io_context io_context;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tcp<span style="color:#f92672">::</span>socket socket(io_context);
</span></span><span style="display:flex;"><span>tcp<span style="color:#f92672">::</span>resolver resolver(io_context);
</span></span><span style="display:flex;"><span>ssl<span style="color:#f92672">::</span>stream<span style="color:#f92672">&lt;</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&amp;&gt;*</span> ssl_stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> endpoints <span style="color:#f92672">=</span> resolver.resolve(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#e6db74">&#34;9150&#34;</span>);
</span></span><span style="display:flex;"><span>asio<span style="color:#f92672">::</span>connect(socket, endpoints);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Connessione stabilita con successo.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span></code></pre></div><p>连接到套接字后，首先要做的是向服务器发送初始问候，以通知我们要使用SOCKS5协议。
有关SOCKS5的详细信息，请参考<a href="https://tools.ietf.org/html/rfc1928">IETF.ORG</a>
首先，您需要知道初始问候由三个连续的字节组成：</p>
<ol>
<li>
<ul>
<li>套接字版本</li>
</ul>
</li>
<li>
<ul>
<li>认证方法数量</li>
</ul>
</li>
<li>
<ul>
<li>认证方法</li>
</ul>
</li>
</ol>
<p>对于第一个字节，我们有0x5，这是套接字版本（SOCKS5），对于第二个字节，我们有客户端支持的认证方法数量，在这种情况下，TOR仅接受一个，即0x1，而第三个字节指定选择的认证方法，在这种情况下将是0x0，表示无认证。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Send the SOCKS5 greeting.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>socket.send(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x05\x01\x00</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">3</span>));
</span></span></code></pre></div><p>此时，我们只需读取代理返回的响应，以了解一切是否顺利，方法是读取响应的第二个字节，该字节应始终为0x0。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Receive the response to the SOCKS5 greeting.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> response[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>size_t length <span style="color:#f92672">=</span> socket.receive(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(response, <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Check the response to the SOCKS5 greeting.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (length <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span> response[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\x00&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>如果一切顺利，我们只需告诉代理服务器为我们连接到特定主机，以便我们可以发送和接收请求。
我们将以与初始问候相同的方式进行，但使用不同的字节。在这种情况下，我们有四个初始字节，指定的主机，以及一个或两个最终字节来指定端口（HTTP/HTTPS - 80/443）。</p>
<ol>
<li>
<ul>
<li>套接字版本</li>
</ul>
</li>
<li>
<ul>
<li>命令</li>
</ul>
</li>
<li>
<ul>
<li>保留</li>
</ul>
</li>
<li>
<ul>
<li>地址类型</li>
</ul>
</li>
<li>
<ul>
<li>地址长度（仅在域类型时）</li>
</ul>
</li>
<li>
<ul>
<li>地址</li>
</ul>
</li>
<li>
<ul>
<li>端口</li>
</ul>
</li>
</ol>
<p>作为第一个字节，我们有0x5，这是套接字版本（SOCK-5），作为第二个字节，我们有要执行的命令，在这种情况下将是0x1，表示连接，作为第三个字节，我们有一个保留字节，它必须始终为0x0，作为第四个字节，我们有我们正在指定的地址类型，在这种情况下将是0x3，表示域地址，但也可以是0x1连接到IPv4，或0x4连接到IPv6。
在这些字节之后，需要在第五个字节中指定要连接的域的长度，并立即通过域指定主机，最后一个或两个字节是要连接到的端口，其中最常见的是80（0x50）用于HTTP，443（0x01 0xBB）用于HTTPS。
所有可用的命令都可以在<a href="https://tools.ietf.org/html/rfc1928">IETF.ORG</a>网站上查看和记录。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>byte<span style="color:#f92672">*</span> request <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> byte[<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span>memset(request, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(request));
</span></span><span style="display:flex;"><span>sprintf(request, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x05\x01\x00\x03</span><span style="color:#e6db74">%c%s</span><span style="color:#ae81ff">\x01\xBB</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(host.size()), host.c_str());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Send the request.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>socket.send(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(request, <span style="color:#ae81ff">7</span> <span style="color:#f92672">+</span> host.size()));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span>[] request;
</span></span></code></pre></div><p>最后，我们只需要像往常一样检查服务器的响应，这种情况下应该是十个字节长，我们只会读取并专门处理第二个字节，因为它返回我们请求的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Receive the response to the SOCKS5 connection request.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> length_response <span style="color:#f92672">=</span> socket.receive(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(buffer, <span style="color:#ae81ff">10</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (length_response <span style="color:#f92672">!=</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">||</span> buffer[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\x00&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 0x1: General failure of the socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x2: Connection&#39;s rule not allowed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x3: Network not available
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x4: Host not available
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x5: Connection refused (SOCK5 not available)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x6: Timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x7: Command not supported
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x8: Address type not supported
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一些洋葱域名可能不接受通过SOCK5的传入连接，在这种情况下，如果您不是域名所有者，则无法做太多事情。
然而，在这一点上，我们可以继续发送实际请求。
如果进行了HTTPS请求，则需要通过具有相应握手的SSL流发送加密请求，否则服务器将无法解释它。
另一方面，如果进行了HTTP请求，则应避免这种情况，因为服务器期望清晰的请求，因此不加密。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Create the SSL stream for the new connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssl<span style="color:#f92672">::</span>context ctx(ssl<span style="color:#f92672">::</span>context<span style="color:#f92672">::</span>sslv23);
</span></span><span style="display:flex;"><span>ssl_stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ssl<span style="color:#f92672">::</span>stream<span style="color:#f92672">&lt;</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&amp;&gt;</span>(socket, ctx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Perform the SSL/TLS handshake
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssl_stream<span style="color:#f92672">-&gt;</span>handshake(ssl<span style="color:#f92672">::</span>stream_base<span style="color:#f92672">::</span>client);
</span></span></code></pre></div><p>在执行SSL流和握手后（如果对于HTTPS是必要的），我们继续发送实际请求：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Prepare the HTTP request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string target <span style="color:#f92672">=</span> api;
</span></span><span style="display:flex;"><span>http<span style="color:#f92672">::</span>request<span style="color:#f92672">&lt;</span>http<span style="color:#f92672">::</span>string_body<span style="color:#f92672">&gt;</span> req(http<span style="color:#f92672">::</span>verb<span style="color:#f92672">::</span>get, target, <span style="color:#ae81ff">11</span>); <span style="color:#75715e">// Si specifica il metodo (GET/POST/PUT), l&#39;host e la versione dell&#39;HTTP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>req.set(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>host, host); <span style="color:#75715e">// Si specifica l&#39;host
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>req.set(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>user_agent, <span style="color:#e6db74">&#34;Mozilla/5.0 (Windows NT 6.1; rv:31.0) Gecko/20100101 Firefox/31.0&#34;</span>); <span style="color:#75715e">// Si specifica l&#39;User-Agent (Browser)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>req.set(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>connection, <span style="color:#e6db74">&#34;keep-alive&#34;</span>); <span style="color:#75715e">// Si specifica la connessione come persistente (Opzionale)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Send the HTTP request over the SSL connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>http<span style="color:#f92672">::</span>write(<span style="color:#f92672">*</span>ssl_stream, req);
</span></span></code></pre></div><p>此时，我们只需最终接收我们请求的响应以及退出代码，以了解请求的结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Receive the HTTP response
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>beast<span style="color:#f92672">::</span>flat_buffer buffer;
</span></span><span style="display:flex;"><span>http<span style="color:#f92672">::</span>response<span style="color:#f92672">&lt;</span>http<span style="color:#f92672">::</span>dynamic_body<span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>http<span style="color:#f92672">::</span>read(<span style="color:#f92672">*</span>ssl_stream, buffer, res); <span style="color:#75715e">//Otteniamo la risposta e salviamola in res
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string req_response <span style="color:#f92672">=</span> beast<span style="color:#f92672">::</span>buffers_to_string(res.body().data()); <span style="color:#75715e">// Convertiamo la risposta in una stringa
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (res.result_int() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">200</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 200 = HTTP_OK
</span></span></span></code></pre></div><p>一旦我们完成了请求，我们需要关闭与代理服务器的连接并释放为SSL流分配的内存：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>boost<span style="color:#f92672">::</span>system<span style="color:#f92672">::</span>error_code ec;
</span></span><span style="display:flex;"><span>ssl_stream<span style="color:#f92672">-&gt;</span>shutdown(ec); <span style="color:#75715e">// Spegniamo lo stream SSL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> ssl_stream;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>socket.close(); <span style="color:#75715e">// Chiudiamo il socket
</span></span></span></code></pre></div><p>我们已成功发出请求并获得了响应。</p>
<h2 id="安装指南">安装指南<a href="#安装指南" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>安装<strong>CppOnionBridge</strong>需要一些预备步骤，包括在开发环境中配置Boost和OpenSSL，以及配置一个通过端口9150运行的Tor服务的活动实例。</p>
<h3 id="安装步骤">安装步骤：<a href="#安装步骤" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li>确保Boost和OpenSSL已安装并在系统中正确配置。</li>
<li>验证Tor服务处于活动状态并设置为通过端口9150连接。</li>
<li>克隆<strong>CppOnionBridge</strong>的GitHub存储库并将其包含在您的项目中。</li>
</ol>
<h2 id="为项目做贡献">为项目做贡献<a href="#为项目做贡献" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><strong>CppOnionBridge</strong>是一个开源项目，社区参与对于其持续发展和改进至关重要。如果您有兴趣通过代码、文档或测试进行贡献，请访问<a href="https://github.com/dano20zombie/CppOnionBridge">GitHub存储库</a>。</p>
<h2 id="结论">结论<a href="#结论" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><strong>CppOnionBridge</strong>代表了向民主化安全和匿名访问互联网迈出的重要一步。凭借其易于集成、最小依赖和与Tor网络兼容性，它为开发尊重用户隐私和安全的应用程序开辟了新的领域。</p>
<p>有关更多详细信息、参考资料和安装指南，请参阅GitHub存储库上提供的<a href="https://github.com/dano20zombie/CppOnionBridge">完整文档</a>。</p>

      </div></div>

  
    
  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
