<!DOCTYPE html>
<html lang="es">
<head>
  
    <title>CppOnionBridge: Innovación en el Acceso Anónimo a Internet :: El blog de dano20zombie</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Explora CppOnionBridge, la solución definitiva para navegar anónimamente por Internet. Este post profundiza en cómo el proyecto proporciona acceso seguro y protegido a sitios onion y APIs a través de la red Tor, enfatizando la importancia de la privacidad y la seguridad en línea en la era digital. Ideal para usuarios de Windows que buscan mejorar su experiencia en línea mientras mantienen resguardada su identidad digital." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://dano20zombie.github.io/es/posts/cpponionbridge/" />






  
  
  
  
  
  <link rel="stylesheet" href="https://dano20zombie.github.io/styles.css">







  <link rel="shortcut icon" href="https://dano20zombie.github.io/favicon.ico">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="es" />
<meta property="og:type" content="article" />
<meta property="og:title" content="CppOnionBridge: Innovación en el Acceso Anónimo a Internet">
<meta property="og:description" content="Explora CppOnionBridge, la solución definitiva para navegar anónimamente por Internet. Este post profundiza en cómo el proyecto proporciona acceso seguro y protegido a sitios onion y APIs a través de la red Tor, enfatizando la importancia de la privacidad y la seguridad en línea en la era digital. Ideal para usuarios de Windows que buscan mejorar su experiencia en línea mientras mantienen resguardada su identidad digital." />
<meta property="og:url" content="https://dano20zombie.github.io/es/posts/cpponionbridge/" />
<meta property="og:site_name" content="El blog de dano20zombie" />

  
    <meta property="og:image" content="https://dano20zombie.github.io/favicon.ico">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="Seguridad" />

  <meta property="article:section" content="Tecnología" />


  <meta property="article:published_time" content="2024-02-17 00:00:00 &#43;0000 UTC" />












</head>
<body class="red">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/es">
  <div class="logo">
    El blog de dano20zombie
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/es/about">Sobre mí</a></li>
        
      
        
          <li><a href="/es/showcase">Vitrina</a></li>
        
      
      
        <hr />
        
          <li>
            <a href="https://dano20zombie.github.io/en/">English</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/zh/">中文</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/es/">Español</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/fr/">Français</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/it/">Italiano</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/ar/">العربية</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/de/">Deutsch</a>
          </li>
        
          <li>
            <a href="https://dano20zombie.github.io/ru/">Русский</a>
          </li>
        
      
    </ul>
  </li>
</ul>

    
    
      <ul class="menu menu--desktop menu--language-selector">
  <li class="menu__trigger">Español&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        <li><a href="https://dano20zombie.github.io/en/">English</a></li>
      
        <li><a href="https://dano20zombie.github.io/zh/">中文</a></li>
      
        <li><a href="https://dano20zombie.github.io/es/">Español</a></li>
      
        <li><a href="https://dano20zombie.github.io/fr/">Français</a></li>
      
        <li><a href="https://dano20zombie.github.io/it/">Italiano</a></li>
      
        <li><a href="https://dano20zombie.github.io/ar/">العربية</a></li>
      
        <li><a href="https://dano20zombie.github.io/de/">Deutsch</a></li>
      
        <li><a href="https://dano20zombie.github.io/ru/">Русский</a></li>
      
    </ul>
  </li>
</ul>

    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/es/about" >Sobre mí</a></li>
        
      
        
          <li><a href="/es/showcase" >Vitrina</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://dano20zombie.github.io/es/posts/cpponionbridge/">CppOnionBridge: Innovación en el Acceso Anónimo a Internet</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-02-17</time><span class="post-reading-time">8 min read (1663 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://dano20zombie.github.io/es/tags/cpponionbridge/">CppOnionBridge</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/es/tags/red-tor/">Red Tor</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/es/tags/anonimato-en-l%C3%ADnea/">Anonimato en Línea</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/es/tags/ciberseguridad/">Ciberseguridad</a>&nbsp;
      
      #<a href="https://dano20zombie.github.io/es/tags/c&#43;&#43;/">C&#43;&#43;</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h2 id="descargo-de-responsabilidad">Descargo de responsabilidad<a href="#descargo-de-responsabilidad" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Este post y el proyecto CppOnionBridge tienen como objetivo promover la privacidad y la seguridad en línea. El uso de herramientas para navegar anónimamente por Internet siempre debe realizarse cumpliendo con las leyes y regulaciones locales. Recordamos que la responsabilidad por el uso de dichas herramientas recae en el usuario final. Este contenido se proporciona &ldquo;tal cual&rdquo;, sin ningún tipo de garantía sobre su precisión o puntualidad.</p>
<h2 id="introducción">Introducción<a href="#introducción" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>En el contexto actual, donde la privacidad en línea está constantemente amenazada, <strong>CppOnionBridge</strong> se presenta como una solución de vanguardia para garantizar un acceso anónimo y seguro a Internet. Este proyecto, desarrollado con un enfoque en entornos Windows, permite una navegación segura a sitios onion y APIs a través de la red Tor, utilizando el protocolo SOCKS5.</p>
<h2 id="visión">Visión<a href="#visión" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>La visión detrás de <strong>CppOnionBridge</strong> es clara: proporcionar una herramienta que no solo protege la identidad en línea de los usuarios, sino que también hace accesible el poder de la red Tor a desarrolladores y usuarios finales con un esfuerzo técnico mínimo. Este proyecto encapsula la complejidad de las conexiones SSL/TLS y las solicitudes HTTP(S) a través de Tor, permitiendo centrarse en la funcionalidad de la aplicación.</p>
<h2 id="características-y-beneficios">Características y Beneficios<a href="#características-y-beneficios" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li><strong>Facilidad de Integración</strong>: Diseñado para integrarse fácilmente en aplicaciones C++, <strong>CppOnionBridge</strong> reduce la barrera de entrada para el desarrollo de aplicaciones seguras.</li>
<li><strong>Dependencias Mínimas</strong>: Con solo dependencias en Boost para operaciones de red y sistema, y OpenSSL para conexiones cifradas, se mantiene ligero y agnóstico al entorno de desarrollo.</li>
<li><strong>Compatibilidad con SOCKS5</strong>: Asegura una interacción fluida y segura con la red Tor, abriendo el camino para una amplia gama de aplicaciones que requieren anonimato y seguridad.</li>
</ul>
<h2 id="qué-es-socks5">¿Qué es SOCKS5?<a href="#qué-es-socks5" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>SOCKS es un protocolo de Internet que intercambia paquetes de red entre un cliente y un servidor a través de un servidor proxy. SOCKS5 proporciona opcionalmente autenticación, para que solo los usuarios autorizados puedan acceder a un servidor.</p>
<h2 id="por-qué-socks5">¿Por qué SOCKS5?<a href="#por-qué-socks5" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>El protocolo SOCKS5 fue elegido por su flexibilidad y seguridad. Su arquitectura cliente-servidor permite encapsular las solicitudes HTTP(S) y las conexiones SSL/TLS a través de Tor, garantizando una interacción segura y anónima con la red. Además, su compatibilidad con una amplia gama de aplicaciones lo convierte en una elección ideal para garantizar el anonimato y la seguridad en línea. (<a href="https://es.wikipedia.org/wiki/SOCKS">Wikipedia</a>)
El servidor SOCKS5 actúa como un proxy entre tú y el host final, enviando paquetes desde tu computadora hacia el otro lado de la conexión, y viceversa.
TOR ya nos proporciona una interfaz SOCKS5, que se basa en el puerto local predeterminado 9050, pero en este ejemplo, utilizaremos el puerto 9150.</p>
<h2 id="cómo-funciona">Cómo Funciona<a href="#cómo-funciona" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>CppOnionBridge depende de dos bibliotecas externas: Boost y OpenSSL, así que comencemos incluyéndolas en nuestro proyecto:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/http.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/ssl.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/beast/version.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/connect.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/ip/tcp.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/ssl/error.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/asio/ssl/stream.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment(lib, &#34;libcrypto64MD.lib&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment(lib, &#34;libssl64MD.lib&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Definizioni di namespace per semplificare il codice
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> beast <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>beast;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> http <span style="color:#f92672">=</span> beast<span style="color:#f92672">::</span>http;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> ssl <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>ssl;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> asio <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>asio;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> error <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>error;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> tcp <span style="color:#f92672">=</span> asio<span style="color:#f92672">::</span>ip<span style="color:#f92672">::</span>tcp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> host <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bible4u2lvhacg4b3to2e2veqpwmrc2c3tjf2wuuqiz332vlwmr4xbad.onion&#34;</span>; <span style="color:#75715e">// Bible4u
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> api <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/en/about&#34;</span>; <span style="color:#75715e">// About Page
</span></span></span></code></pre></div><p>Habiendo hecho eso, como nuestro primer paso real, necesitamos crear un socket y conectarnos a la dirección localhost, con nuestro puerto especificado (127.0.0.1:9150):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>asio<span style="color:#f92672">::</span>io_context io_context;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tcp<span style="color:#f92672">::</span>socket socket(io_context);
</span></span><span style="display:flex;"><span>tcp<span style="color:#f92672">::</span>resolver resolver(io_context);
</span></span><span style="display:flex;"><span>ssl<span style="color:#f92672">::</span>stream<span style="color:#f92672">&lt;</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&amp;&gt;*</span> ssl_stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> endpoints <span style="color:#f92672">=</span> resolver.resolve(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#e6db74">&#34;9150&#34;</span>);
</span></span><span style="display:flex;"><span>asio<span style="color:#f92672">::</span>connect(socket, endpoints);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Connessione stabilita con successo.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span></code></pre></div><p>Una vez conectados al socket, lo primero que debemos hacer es enviar el saludo inicial al servidor, para comunicar que queremos utilizar el protocolo SOCKS5.
Para obtener información detallada sobre SOCKS5, puedes consultar <a href="https://tools.ietf.org/html/rfc1928">IETF.ORG</a>
Es importante tener en cuenta que el saludo inicial consta de tres bytes individuales en secuencia:</p>
<ol>
<li>
<ul>
<li>VERSIÓN DEL SOCKET</li>
</ul>
</li>
<li>
<ul>
<li>NÚMERO DE MÉTODOS DE AUTENTICACIÓN</li>
</ul>
</li>
<li>
<ul>
<li>MÉTODOS DE AUTENTICACIÓN</li>
</ul>
</li>
</ol>
<p>Para el primer byte, tenemos 0x5, que es la versión del socket (SOCKS5), mientras que para el segundo byte tenemos el número de métodos de autenticación admitidos por el cliente, donde en este caso TOR solo acepta uno, que es 0x1, mientras que el tercer byte especifica el método de autenticación elegido, que en este caso será 0x0, lo que significa ninguna autenticación.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Send the SOCKS5 greeting.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>socket.send(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x05\x01\x00</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">3</span>));
</span></span></code></pre></div><p>En este punto, solo necesitamos leer la respuesta devuelta por el proxy para saber si todo salió bien o no, leyendo el segundo byte de la respuesta, que siempre debería ser 0x0.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Receive the response to the SOCKS5 greeting.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> response[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>size_t length <span style="color:#f92672">=</span> socket.receive(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(response, <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Check the response to the SOCKS5 greeting.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (length <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span> response[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\x00&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>Se todo salió bien, lo único que nos queda es decirle al servidor proxy que se conecte a un host específico para que podamos enviar y recibir solicitudes.
Procederemos de la misma manera que con el saludo inicial pero con bytes diferentes. En este caso, tenemos cuatro bytes iniciales, el host especificado, y uno o dos bytes finales para especificar el puerto (HTTP/HTTPS - 80/443).</p>
<ol>
<li>
<ul>
<li>VERSIÓN DEL SOCKET</li>
</ul>
</li>
<li>
<ul>
<li>COMANDO</li>
</ul>
</li>
<li>
<ul>
<li>RESERVADO</li>
</ul>
</li>
<li>
<ul>
<li>TIPO DE DIRECCIÓN</li>
</ul>
</li>
<li>
<ul>
<li>LONGITUD DE LA DIRECCIÓN (SOLO SI ES DE TIPO DOMINIO)</li>
</ul>
</li>
<li>
<ul>
<li>DIRECCIÓN</li>
</ul>
</li>
<li>
<ul>
<li>PUERTO</li>
</ul>
</li>
</ol>
<p>Como primer byte, tenemos 0x5, que es la versión del socket (SOCK-5), como segundo byte, tenemos el comando que queremos ejecutar, donde en este caso será 0x1, lo que significa conexión, como tercer byte tenemos un byte reservado, que siempre debe ser 0x0, y como cuarto byte tenemos el tipo de dirección que estamos especificando, donde en este caso será 0x3, lo que significa una dirección de dominio, pero también podría ser 0x1 para conectarse a un IPv4, o 0x4 para conectarse a un IPv6.
Después de estos bytes, es necesario especificar la longitud del dominio al que conectarse, en el quinto byte, e inmediatamente después especificar el host a través del dominio, y como último uno o dos bytes tenemos el puerto al que conectarse, donde los más comunes son 80 (0x50) para HTTP, y 443 (0x01 0xBB) para HTTPS.
Todos los comandos disponibles son visibles y documentados en el sitio <a href="https://tools.ietf.org/html/rfc1928">IETF.ORG</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>byte<span style="color:#f92672">*</span> request <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> byte[<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span>memset(request, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(request));
</span></span><span style="display:flex;"><span>sprintf(request, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x05\x01\x00\x03</span><span style="color:#e6db74">%c%s</span><span style="color:#ae81ff">\x01\xBB</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(host.size()), host.c_str());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Send the request.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>socket.send(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(request, <span style="color:#ae81ff">7</span> <span style="color:#f92672">+</span> host.size()));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">delete</span>[] request;
</span></span></code></pre></div><p>Finalmente, solo necesitamos verificar como siempre la respuesta del servidor, donde en este caso debería tener una longitud de diez bytes, de los cuales leeremos exclusivamente el segundo, ya que devuelve el estado de nuestra solicitud.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Receive the response to the SOCKS5 connection request.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> length_response <span style="color:#f92672">=</span> socket.receive(boost<span style="color:#f92672">::</span>asio<span style="color:#f92672">::</span>buffer(buffer, <span style="color:#ae81ff">10</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (length_response <span style="color:#f92672">!=</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">||</span> buffer[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\x00&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 0x1: General failure of the socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x2: Connection&#39;s rule not allowed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x3: Network not available
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x4: Host not available
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x5: Connection refused (SOCK5 not available)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x6: Timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x7: Command not supported
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0x8: Address type not supported
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Algunos dominios onion pueden no aceptar conexiones entrantes a través de SOCK5, en este caso, si no se es el propietario del dominio, no hay mucho que se pueda hacer al respecto.
De todos modos, una vez llegados a este punto, podemos proceder con el envío de la solicitud real.
Si se realiza una solicitud HTTPS, es necesario enviar la solicitud encriptada, a través de un flujo SSL con el correspondiente handshake, de lo contrario, el servidor no podrá interpretarla.
Por otro lado, esto debería evitarse si se realiza una solicitud HTTP, donde en este caso el servidor espera una solicitud clara, por lo tanto, no encriptada.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Create the SSL stream for the new connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssl<span style="color:#f92672">::</span>context ctx(ssl<span style="color:#f92672">::</span>context<span style="color:#f92672">::</span>sslv23);
</span></span><span style="display:flex;"><span>ssl_stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ssl<span style="color:#f92672">::</span>stream<span style="color:#f92672">&lt;</span>tcp<span style="color:#f92672">::</span>socket<span style="color:#f92672">&amp;&gt;</span>(socket, ctx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Perform the SSL/TLS handshake
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ssl_stream<span style="color:#f92672">-&gt;</span>handshake(ssl<span style="color:#f92672">::</span>stream_base<span style="color:#f92672">::</span>client);
</span></span></code></pre></div><p>Después de realizar un flujo SSL y su handshake (SI ES NECESARIO PARA HTTPS), procedemos con el envío de la solicitud real:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Prepare the HTTP request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string target <span style="color:#f92672">=</span> api;
</span></span><span style="display:flex;"><span>http<span style="color:#f92672">::</span>request<span style="color:#f92672">&lt;</span>http<span style="color:#f92672">::</span>string_body<span style="color:#f92672">&gt;</span> req(http<span style="color:#f92672">::</span>verb<span style="color:#f92672">::</span>get, target, <span style="color:#ae81ff">11</span>); <span style="color:#75715e">// Si specifica il metodo (GET/POST/PUT), l&#39;host e la versione dell&#39;HTTP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>req.set(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>host, host); <span style="color:#75715e">// Si specifica l&#39;host
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>req.set(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>user_agent, <span style="color:#e6db74">&#34;Mozilla/5.0 (Windows NT 6.1; rv:31.0) Gecko/20100101 Firefox/31.0&#34;</span>); <span style="color:#75715e">// Si specifica l&#39;User-Agent (Browser)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>req.set(http<span style="color:#f92672">::</span>field<span style="color:#f92672">::</span>connection, <span style="color:#e6db74">&#34;keep-alive&#34;</span>); <span style="color:#75715e">// Si specifica la connessione come persistente (Opzionale)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Send the HTTP request over the SSL connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>http<span style="color:#f92672">::</span>write(<span style="color:#f92672">*</span>ssl_stream, req);
</span></span></code></pre></div><p>En este punto, todo lo que queda es finalmente recibir la respuesta a nuestra solicitud junto con el código de salida para conocer el resultado de la solicitud.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Receive the HTTP response
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>beast<span style="color:#f92672">::</span>flat_buffer buffer;
</span></span><span style="display:flex;"><span>http<span style="color:#f92672">::</span>response<span style="color:#f92672">&lt;</span>http<span style="color:#f92672">::</span>dynamic_body<span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>http<span style="color:#f92672">::</span>read(<span style="color:#f92672">*</span>ssl_stream, buffer, res); <span style="color:#75715e">//Otteniamo la risposta e salviamola in res
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string req_response <span style="color:#f92672">=</span> beast<span style="color:#f92672">::</span>buffers_to_string(res.body().data()); <span style="color:#75715e">// Convertiamo la risposta in una stringa
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (res.result_int() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">200</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 200 = HTTP_OK
</span></span></span></code></pre></div><p>Una vez que hayamos terminado con nuestra solicitud, necesitamos cerrar la conexión con el servidor proxy y liberar la memoria asignada para el flujo SSL:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>boost<span style="color:#f92672">::</span>system<span style="color:#f92672">::</span>error_code ec;
</span></span><span style="display:flex;"><span>ssl_stream<span style="color:#f92672">-&gt;</span>shutdown(ec); <span style="color:#75715e">// Spegniamo lo stream SSL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> ssl_stream;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>socket.close(); <span style="color:#75715e">// Chiudiamo il socket
</span></span></span></code></pre></div><p>Y aquí hemos realizado con éxito nuestra solicitud y obtenido la respuesta.</p>
<h2 id="guía-de-instalación">Guía de Instalación<a href="#guía-de-instalación" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>La instalación de <strong>CppOnionBridge</strong> requiere algunos pasos preliminares, que incluyen configurar Boost y OpenSSL en tu entorno de desarrollo, así como tener una instancia activa del servicio Tor configurada para operar a través del puerto 9150.</p>
<h3 id="pasos-de-instalación">Pasos de Instalación:<a href="#pasos-de-instalación" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li>Asegúrate de que Boost y OpenSSL estén instalados y configurados correctamente en el sistema.</li>
<li>Verifica que el servicio Tor esté activo y configurado para conectarse a través del puerto 9150.</li>
<li>Clona el repositorio de GitHub de <strong>CppOnionBridge</strong> e inclúyelo en tu proyecto.</li>
</ol>
<h2 id="contribuir-al-proyecto">Contribuir al Proyecto<a href="#contribuir-al-proyecto" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><strong>CppOnionBridge</strong> es un proyecto de código abierto, y la participación de la comunidad es esencial para su desarrollo continuo y mejora. Si estás interesado en contribuir, ya sea a través de código, documentación o pruebas, visita el <a href="https://github.com/dano20zombie/CppOnionBridge">repositorio de GitHub</a>.</p>
<h2 id="conclusión">Conclusión<a href="#conclusión" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p><strong>CppOnionBridge</strong> representa un paso significativo hacia la democratización del acceso seguro y anónimo a Internet. Con su facilidad de integración, dependencias mínimas y compatibilidad con la red Tor, abre nuevas fronteras para el desarrollo de aplicaciones que respeten la privacidad y seguridad de los usuarios.</p>
<p>Para más detalles, referencias y guías de instalación, consulta la <a href="https://github.com/dano20zombie/CppOnionBridge">documentación completa</a> disponible en el repositorio de GitHub.</p>

      </div></div>

  
    
  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
